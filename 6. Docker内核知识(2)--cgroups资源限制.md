## **cgroups资源限制**

1. cgroups的作用

   （１）资源限制：cgroups可以对任务使用的资源总量进行限制，如果设定有运行时内存使用上限，则在超过这一份额时就发出OOM(Out of Memory)提示。

   （２）优先级分配：通过分配CPU时间片数量和磁盘IO带宽大小，实际上就相当于控制了任务运行的优先级。

   （３）资源统计：cgroups可以统计系统的CPU使用时长、内存用量等资源使用量，可用来计费。

   （４）任务控制：cgroups可以对任务执行挂起、恢复等操作。

2. cgroups术语

   （１）task(任务)：表示系统的一个进程或线程

   （２）cgroup(控制组)：cgroups中的资源控制都以cgroup为单位实现。cgroup表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个cgroup，也可以从某个cgroup迁移到另一个cgroup。

   （３）subsystem(子系统)：资源调度控制器。如CPU子系统可以控制CPU时间分配，内存子系统可以限制cgroup内存使用量。

   （４）hierarchy(层级)：层级有一系列cgroup以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。层级中的cgroup节点可以包含零个或多个子节点，子节点继承父节点挂载的子系统。整个操作系统可以有多个层级。

3. 组织结构和基本规则

   ```mermaid
   graph LR
       cgroup_Hierarchy --- Memory
       subgraph cgroup_Hierarchy
       root_cgroup---cgroup1-cgroupn
       end
       cgroup_Hierarchy---CPU
   ```

   ​

   多个cgroup构成的层级并非单根结构，可以允许有多个。每个子系统独自构成一个层级。

   **规则1：**同一层级可以附加一个或多个子系统。

   如，可以将一个层级同时附着在CPU子系统和Memory子系统上

   **规则2：**一个子系统可以附着到多个层级，当且仅当目标层级只有唯一一个子系统

   **规则3：**系统每次新建一个层级时，该系统上的所有任务默认加入这个新建层级的初始化cgroup，这个cgroup也称为root cgroup。**一个任务不能存在于同一个层级的不同cgroup中，但一个任务可以存在于不同层级的多个cgroup中。**如果操作时把一个任务添加到同一个层级中的另一个cgroup中，则会将它从第一个cgroup中移除。

   **规则4：**任务在fork/clone自身时创建的子任务默认与原任务在一个cgroup中，但是子任务允许被移动到不同的cgroup中。因为父子任务之间已经独立。

4. 子系统简介

   子系统实际就是cgroup的资源控制系统，每个子系统独立地控制机一种资源，目前(2015)Docker使用如下９种子系统，还有net_cls子系统在内核中已经广泛实现，但Docker还未采用。

   |    子系统     |                    功能                    |
   | :--------: | :--------------------------------------: |
   |   blkio    |  可以为块设备设定输入/输出设备，如物理驱动设备（磁盘、固态硬盘、USB等）   |
   |    cpu     |            使用调度程序控制任务对CPU的使用             |
   |  cpuacct   |        自动生成cgroup中任务对CPU资源使用情况的报告        |
   |   cpuset   |     可以为cgroup中的任务分配独立的CPU(多处理机系统)和内存     |
   |  devices   |           开启或关闭cgroup中任务对设备的访问           |
   |  freezer   |            可以挂起或恢复cgroup中的任务             |
   |   memory   |   可以设定cgroup中的任务对内存使用量的限定，并自动生成使用情况报表    |
   | perf_event |        使用后使cgroup中的任务可以进行同一的性能测试         |
   |  net_cls   | 它通过等级标识符(classid)标记网络包，从而允许Linux流量监控程序(Traffic Controller)识别从具体cgroup中生成的数据包 |

   Docker在使用cgroup时的注意事项：

   目前无法将一个新的子系统绑定到激活的层级上，也无法从一个激活的层级中解除某个子系统的绑定

   在一个层级的cgroup文件系统被卸载(unmount)时，如果其中创建过生层次的后代cgroup目录，且层级也处于激活状态，那么其后代cgroup的配置依然有效。只有递归式的卸载层级中的所有cgroup，那个层级才会被删除。